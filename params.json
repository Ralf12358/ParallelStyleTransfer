{"name":"Parallel Style Transfer","tagline":"Jason Israel and Michael Kamm, Going for Real-Time style transfer","body":"## Page Under Construction!\r\n### Summary\r\nWe would like to implement a parallel example-based style transfer algorithm.  We are going to do this on the NVIDIA GPUs in the lab.  We are looking to achieve speedup relative to OpenCV's FLANN (Fast Approximate Nearest-Neighbor Search Library).\r\n\r\n### Background\r\nExample-based style transfer is the process of transferring the \"style\" of one image to another. For example, if we have an image of a watercolor painting and an image of a real-world photograph, we'd like to transfer the \"style\" of the painting to the photograph, while preserving the photographs structure (images below taken from [http://www.mrl.nyu.edu/projects/image-analogies/watercolor.html](http://www.mrl.nyu.edu/projects/image-analogies/watercolor.html))\r\n\r\n![Source Image](http://www.mrl.nyu.edu/projects/image-analogies/images/watercolor.jpg)\r\n[Source Image]\r\n![Unfiltered Destination Image](http://www.mrl.nyu.edu/projects/image-analogies/images/boats.jpg)\r\n[Unfiltered Destination Image]\r\n![Filtered Destination Image](http://www.mrl.nyu.edu/projects/image-analogies/images/watercolor-boats.jpg)\r\n[Filtered Destination Image]\r\n\r\nAn early pixel-based solution of example-based style transfer is by using \"Image Analogies\". An image analogy takes an unfiltered image (A), a styled version of the first image (A'), and applies the style to a third image (B), to create the result (B').  In the form of an analogy, this is A : A' :: B : B'.\r\n\r\nA simple description of the Image Analogy algorithm is as follows:\r\n\r\n```\r\nCompute Gaussian pyramids for A, A', B\r\nfor each level l, from coarsest to finest: \r\n  for each pixel q of B'_l (scan-line order) \r\n    p = BestMatch(A, A', B, B', l, q) \r\n    B'_l(q) = A'_l(p)\r\nreturn B'\r\n```\r\n\r\nBestMatch tries to find the best pixel p in A, such that the neighborhood around A(p) is similar to B(q). We also want to make sure that pixel p would give a coherent result in the already synthesized neighborhood of B'(q). The initial algorithm uses a serial approximate-nearest-neighborhood search to find the best pixel.\r\n\r\nWe see two places in this algorithm where parallelism can be used. One thing we could improve is the approximate nearest neighborhood search. For each pixel q in B', we are trying to find the pixel p in A that has the most similar neighborhood to q in B. Calculating the distances from the neighborhood around B(q) to all the neighborhoods in A is independent, so we will definitely try to parallelize this step.\r\n\r\nAnother way we may be able to speed up this program is by parallelizing across all pixels q in B'. Doing this, however, may lead to very incoherent results (the structure of the original image will get diminished).\r\n\r\nThere are also patch-based solutions to the image style transfer problem.\r\n\r\n### The Challenge\r\nThere are two major challenges in this project:\r\n\r\n1) We need to improve the speed of the approximate-nearest-neighborhood search.\r\n\r\n2) We would like to parallelize across the pixels in the image while maintaining coherence in the result.\r\n\r\n## Preliminary Results\r\n\r\n### Brute-Force Solution\r\nWe started off with a serial, purely exhaustive brute-force solution.  \r\n\r\n### OpenCV FLANN Solution\r\nComplete\r\n\r\n\r\n### CUDA Solution\r\nComing Soon (likely tonight)!\r\n\r\n### Resources\r\nThe basis of our algorithm comes from \"Image Analogies\" http://www.mrl.nyu.edu/publications/image-analogies/analogies-300dpi.pdf.\r\n  \r\nWe have also found a paper detailing a CUDA specific approach to image analogies. http://download.springer.com/static/pdf/45/art%253A10.1007%252Fs00371-012-0701-4.pdf?auth66=1396815636_90dc75f6739fe23fb6a179e7de74a43e&ext=.pdf.  \r\n\r\nAnother approach to style transfer is by using stitching patches of the source image to create the destination. Here is a paper describing that approach: http://mmlab.siat.ac.cn/sfchen/Publications/TMM13-style.pdf\r\n\r\nWe also found a couple papers on Texture Synthesis on the GPU:\r\n\r\nPixel-based: http://research.microsoft.com/en-us/um/people/hoppe/apptexsyn.pdf.\r\n\r\nPatch-based: http://delivery.acm.org/10.1145/2390000/2383813/p115-lasram.pdf?ip=128.237.228.57&id=2383813&acc=ACTIVE%20SERVICE&key=A792924B58C015C1%2E5A12BE0369099858%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&CFID=431509807&CFTOKEN=37457636&__acm__=1396640643_e604d2caf28713d957e3c5fa3b34aa8a\r\n\r\n### Goals\r\nWe would like to show a speedup relative to a FLANN solution.\r\n\r\n### Platform Choice\r\nWe are choosing to use the NVIDIA GPUs in the lab.  Like the second assignment, this project involves math-intensive image manipulation. We plan on using C++ and Cuda. We also use OpenCV for image preprocessing.\r\n\r\n### Schedule\r\n* Week of April 8 - Planning, refining and researching for our initial approach\r\n* Week of April 15 - Write serial version in C++\r\n* Week of April 21 - Parallelize neighborhood search algorithm\r\n* Week of April 28 - Parallelize over pixels/patches (coherence)\r\n* Week of May 5 - Optimization","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}