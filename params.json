{"name":"Parallel Style Transfer","tagline":"Jason Israel and Michael Kamm","body":"### Periodic updates will occur throughout the day as more in-depth analysis is completed!\r\n### Summary\r\nWe would like to implement a parallel example-based style transfer algorithm.  We are going to do this on the NVIDIA GPUs in the lab.  We are looking to achieve speedup relative to OpenCV's FLANN (Fast Approximate Nearest-Neighbor Search Library).\r\n\r\n### Background\r\nExample-based style transfer is the process of transferring the \"style\" of one image to another. For example, if we have an image of a watercolor painting and an image of a real-world photograph, we'd like to transfer the \"style\" of the painting to the photograph, while preserving the photographs structure (images below taken from [http://www.mrl.nyu.edu/projects/image-analogies/watercolor.html](http://www.mrl.nyu.edu/projects/image-analogies/watercolor.html))\r\n\r\n![Source Image](http://www.mrl.nyu.edu/projects/image-analogies/images/watercolor.jpg)\r\n[Source Image]\r\n![Unfiltered Destination Image](http://www.mrl.nyu.edu/projects/image-analogies/images/boats.jpg)\r\n[Unfiltered Destination Image]\r\n![Filtered Destination Image](http://www.mrl.nyu.edu/projects/image-analogies/images/watercolor-boats.jpg)\r\n[Filtered Destination Image]\r\n\r\nAn early pixel-based solution of example-based style transfer is by using \"Image Analogies\". An image analogy takes an unfiltered image (A), a styled version of the first image (A'), and applies the style to a third image (B), to create the result (B').  In the form of an analogy, this is A : A' :: B : B'.\r\n\r\nA simple description of the Image Analogy algorithm is as follows:\r\n\r\n```\r\nCompute Gaussian pyramids for A, A', B\r\nfor each level l, from coarsest to finest: \r\n  for each pixel q of B'_l (scan-line order) \r\n    p = BestMatch(A, A', B, B', l, q) \r\n    B'_l(q) = A'_l(p)\r\nreturn B'\r\n```\r\n\r\nBestMatch tries to find the best pixel p in A, such that the neighborhood around A(p) is similar to B(q). We also want to make sure that pixel p would give a coherent result in the already synthesized neighborhood of B'(q). The initial algorithm uses a serial approximate-nearest-neighborhood search to find the best pixel.\r\n\r\nWe see two places in this algorithm where parallelism can be used. One thing we could improve is the approximate nearest neighborhood search. For each pixel q in B', we are trying to find the pixel p in A that has the most similar neighborhood to q in B. Calculating the distances from the neighborhood around B(q) to all the neighborhoods in A is independent, so we will definitely try to parallelize this step.\r\n\r\nAnother way we may be able to speed up this program is by parallelizing across all pixels q in B'. Doing this, however, may lead to very incoherent results (the structure of the original image will get diminished).\r\n\r\nThere are also patch-based solutions to the image style transfer problem.\r\n\r\n### The Challenge\r\nThere are two major challenges in this project:\r\n\r\n1) We need to improve the speed of the approximate-nearest-neighborhood search.\r\n\r\n2) We would like to parallelize across the pixels in the image while maintaining coherence in the result.\r\n\r\n## Preliminary Results\r\n\r\n### Brute-Force Solution\r\nWe started off with a serial, purely exhaustive brute-force solution.  We quickly found out that a pure brute-force solution is not adequate for this problem on anything but a small scale.  However, this solution is always exactly correct, barring some minor sub-optimal choices by the initial k-coherence algorithm.  On the small images shown here, the brute-force algorithm required about 15 minutes to complete.\r\n\r\n![A](https://raw.githubusercontent.com/jaisrael/ParallelStyleTransfer/gh-pages/src/serial/Images/newflower-src.jpg) \r\n\r\n![A'](https://raw.githubusercontent.com/jaisrael/ParallelStyleTransfer/gh-pages/src/serial/Images/newflower-blur.jpg)\r\n\r\n![B](https://raw.githubusercontent.com/jaisrael/ParallelStyleTransfer/gh-pages/src/serial/Images/toy-newshore-src.jpg)\r\n\r\n![B'](https://raw.githubusercontent.com/jaisrael/ParallelStyleTransfer/gh-pages/src/serial/Results/flann_coh1_YIQtoy-newshore-src.jpg-l5.jpg)\r\n\r\n\r\n### OpenCV FLANN Solution\r\nOur next version avoided brute-force as much as possible, by taking advantage of OpenCV's FLANN library.  \r\nThis achieved much faster results, and we could start to run our algorithm on larger images with artistic filters.  These images took about 15 seconds to render.  A pure brute-force solution would have taken several hours to complete.\r\n\r\nPastel Filter\r\n\r\n![A](https://raw.githubusercontent.com/jaisrael/ParallelStyleTransfer/gh-pages/src/serial/Images/pastel-src.jpg)\r\n\r\n![A'](https://raw.githubusercontent.com/jaisrael/ParallelStyleTransfer/gh-pages/src/serial/Images/pastel.jpg)\r\n\r\n![B](https://raw.githubusercontent.com/jaisrael/ParallelStyleTransfer/gh-pages/src/serial/Images/darkclouds.jpg)\r\n\r\n![B'](https://raw.githubusercontent.com/jaisrael/ParallelStyleTransfer/gh-pages/src/serial/Results/ALL_FLANNdarkclouds.jpg-l3.jpg)\r\n\r\nWatercolor Filter\r\n\r\n![B'](https://raw.githubusercontent.com/jaisrael/ParallelStyleTransfer/gh-pages/src/serial/Results/ALL_FLANNdarkclouds.jpg-l4.jpg)\r\n\r\n### CUDA Solution\r\nThis algorithm breaks away from the inherent dependencies of neighborhoods in the interest of parallelism.  This comes at a cost of correctness, but acceptable correctness is achieved through the use of several correction passes, where the neighborhoods are updated between passes.\r\n\r\nCurrently, we have a correct, but naive, CUDA solution.  We have successfully parallelized a brute force solution, and it is achieving speedups relative to our initial brute force method.\r\n\r\nRight now, we are exploring ways to improve speed and correctness.  To improve the speed, we are exploring different ways to use memory.  Right now, everything is stored in global memory, and using texture memory for some of our matrices has potential for speedup.\r\n\r\nTo improve correctness, we are fiddling with the amount of correctness passes, and the effect of k-coherence search.\r\n\r\n### Resources\r\nThe basis of our algorithm comes from \"Image Analogies\" http://www.mrl.nyu.edu/publications/image-analogies/analogies-300dpi.pdf.\r\n  \r\nWe have also found a paper detailing a CUDA specific approach to image analogies. http://download.springer.com/static/pdf/45/art%253A10.1007%252Fs00371-012-0701-4.pdf?auth66=1396815636_90dc75f6739fe23fb6a179e7de74a43e&ext=.pdf.  \r\n\r\nAnother approach to style transfer is by using stitching patches of the source image to create the destination. Here is a paper describing that approach: http://mmlab.siat.ac.cn/sfchen/Publications/TMM13-style.pdf\r\n\r\nWe also found a couple papers on Texture Synthesis on the GPU:\r\n\r\nPixel-based: http://research.microsoft.com/en-us/um/people/hoppe/apptexsyn.pdf.\r\n\r\nPatch-based: http://delivery.acm.org/10.1145/2390000/2383813/p115-lasram.pdf?ip=128.237.228.57&id=2383813&acc=ACTIVE%20SERVICE&key=A792924B58C015C1%2E5A12BE0369099858%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&CFID=431509807&CFTOKEN=37457636&__acm__=1396640643_e604d2caf28713d957e3c5fa3b34aa8a\r\n\r\n### Goals\r\nWe would like to show a speedup relative to a FLANN solution.\r\n\r\n### Platform Choice\r\nWe are choosing to use the NVIDIA GPUs in the lab.  Like the second assignment, this project involves math-intensive image manipulation. We plan on using C++ and Cuda. We also use OpenCV for image preprocessing.\r\n\r\n### Schedule\r\n* Week of April 8 - Planning, refining and researching for our initial approach\r\n* May 1-2 - Write serial version in C++\r\n* May 2-3 - Write FLANN version\r\n* May 4-5 - Install OpenCV on Gates machines and get it to work with CUDA (a nightmare)\r\n* May 6-8 - Implement CUDA version\r\n* May 8 - Conduct analysis on results","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}